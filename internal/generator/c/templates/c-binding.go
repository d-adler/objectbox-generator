/*
 * Copyright 2019 ObjectBox Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package templates

import (
	"text/template"
)

// TODO how to handle null values?

// CBindingTemplate is used to generated the binding code
var CBindingTemplate = template.Must(template.New("binding").Funcs(funcMap).Parse(
	`// Code generated by ObjectBox; DO NOT EDIT.

#ifndef {{.IfdefGuard}}
#define {{.IfdefGuard}}

#include <stdbool.h>
#include <stdint.h>

#include "flatcc/flatcc.h"
#include "flatcc/flatcc_builder.h"
#include "objectbox.h"
{{range $entity := .Model.EntitiesWithMeta}}{{with $entity.Meta.CppNamespaceStart}}
{{.}}{{end}}
typedef struct {{$entity.Meta.CppName}} {
	{{- range $property := $entity.Properties}}
	{{$property.Meta.CppType}} {{$property.Meta.CppName}};
	{{- end}}
} {{$entity.Meta.CppName}};

enum {{$entity.Meta.CppName}}_ {
	{{$entity.Meta.CppName}}_ENTITY_ID = {{$entity.Id.GetId}},
{{- range $property := $entity.Properties}}
	{{$entity.Meta.CppName}}_PROP_ID_{{$property.Meta.CppName}} = {{$property.Id.GetId}},
{{- end}}
}

/// Write given object to the FlatBufferBuilder
static bool {{$entity.Meta.CppName}}_to_flatbuffer(flatcc_builder_t* B, const Simple *object, void **out_buffer, size_t *out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);

    if (flatcc_builder_start_table(B, /* TODO len(properties) */ 2) != 0) return false;

    void* p;
    p = flatcc_builder_table_add(B, /* TODO prop ID */ 0, /* TODO size of c type used to store the property value */ sizeof(object->id), /* TODO align, seems to be the same as size */ sizeof(object->id));
    if (p == NULL) return false;

    /* TODO actual property type instead of uint64 */
    flatbuffers_uint64_write_to_pe(p, /* TODO actual property value */ object->id);

    flatcc_builder_ref_t ref = flatcc_builder_end_table(B);
    if (ref == 0) return false;

    *out_buffer = NULL;
    *out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size);
    return *out_buffer != NULL;
}
static inline void {{$entity.Meta.CppName}}_to_flatbuffer(flatbuffers::FlatBufferBuilder& fbb, const {{$entity.Meta.CppName}}& object) {
	fbb.Clear();
	{{- range $property := $entity.Properties}}{{$factory := $property.Meta.FbOffsetFactory}}{{if $factory}}
	auto offset{{$property.Meta.CppName}} = fbb.{{$factory}}(object.{{$property.Meta.CppName}});
	{{- end}}{{end}}
	flatbuffers::uoffset_t fbStart = fbb.StartTable();
	{{range $property := $entity.Properties}}
	{{- if $property.Meta.FbOffsetFactory}}fbb.AddOffset({{$property.FbvTableOffset}}, offset{{$property.Meta.CppName}});
	{{- else if eq "bool" $property.Meta.CppType}}fbb.TrackField({{$property.FbvTableOffset}}, fbb.PushElement<uint8_t>(object.{{$property.Meta.CppName}} ? 1 : 0));
	{{- else}}fbb.TrackField({{$property.FbvTableOffset}}, fbb.PushElement<{{$property.Meta.CppType}}>(object.{{$property.Meta.CppName}}));
	{{- end}}
	{{end -}}
	flatbuffers::Offset<flatbuffers::Table> offset;
	offset.o = fbb.EndTable(fbStart);
	fbb.Finish(offset);
}

/// Read an object from a valid FlatBuffer
static {{$entity.Meta.CppName}} fromFlatBuffer(const void* data, size_t size) {
	{{$entity.Meta.CppName}} object;
	fromFlatBuffer(data, size, object);
	return object;
}

/// Read an object from a valid FlatBuffer
static std::unique_ptr<{{$entity.Meta.CppName}}> newFromFlatBuffer(const void* data, size_t size) {
	auto object = std::unique_ptr<{{$entity.Meta.CppName}}>(new {{$entity.Meta.CppName}}());
	fromFlatBuffer(data, size, *object);
	return object;
}

/// Read an object from a valid FlatBuffer
static void fromFlatBuffer(const void* data, size_t size, {{$entity.Meta.CppName}}& outObject) {
	const auto* table = flatbuffers::GetRoot<flatbuffers::Table>(data);
	assert(table);
	{{range $property := $entity.Properties}}
	{{- if eq "std::vector<std::string>" $property.Meta.CppType}}{
		auto* ptr = table->GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>*>({{$property.FbvTableOffset}});
		if (ptr) {
			outObject.{{$property.Meta.CppName}}.reserve(ptr->size());
			for (size_t i = 0; i < ptr->size(); i++) {
				auto* itemPtr = ptr->Get(i);
				if (itemPtr) outObject.{{$property.Meta.CppName}}.emplace_back(itemPtr->c_str());
			}
		}
	}{{else if $property.Meta.FbOffsetType}}{
		auto* ptr = table->GetPointer<const {{$property.Meta.FbOffsetType}}*>({{$property.FbvTableOffset}});
		if (ptr) outObject.{{$property.Meta.CppName}}.assign(ptr->begin(), ptr->end());
	}{{- else if eq "bool" $property.Meta.CppType}}outObject.{{$property.Meta.CppName}} = table->GetField<uint8_t>({{$property.FbvTableOffset}}, 0) != 0;
	{{- else}}outObject.{{$property.Meta.CppName}} = table->GetField<{{$property.Meta.CppType}}>({{$property.FbvTableOffset}}, {{$property.Meta.FbDefaultValue}});
	{{- end}}
	{{end}}
}
{{with $entity.Meta.CppNamespaceEnd}}{{.}}{{end -}}
{{end}}
#endif  // {{.IfdefGuard}}
`))
