<img width="466" src="https://raw.githubusercontent.com/objectbox/objectbox-java/master/logo.png">

# Do you ♥️ using ObjectBox?

[![Follow ObjectBox on Twitter](https://img.shields.io/twitter/follow/ObjectBox_io.svg?style=flat-square&logo=twitter&color=fff)](https://twitter.com/ObjectBox_io)

We want to [hear about your project](https://docs.google.com/forms/d/e/1FAIpQLScIYiOIThcq-AnDVoCvnZOMgxO4S-fBtDSFPQfWldJnhi2c7Q/viewform)!
It will - literally - take just a minute, but help us a lot. Thank you!​ 🙏​

# ObjectBox Generator

ObjectBox is a superfast object-oriented database with strong relation support. ObjectBox is embedded into your Android, Linux, macOS, or Windows app.

ObjectBox Generator takes over the burden of writing the C/C++ binding code for ObjectBox, greatly simplifying the model declaration and FlatBuffers serialization, allowing you to concentrate on the actual application logic.

All the generated code is header-only and compatible with the existing ObjectBox C-API so you can take advantage of the new features while incrementally porting your existing code.

## Prerequisites/Installation

1. You need to have [ObjectBox-C](https://github.com/objectbox/objectbox-c) library installed to use code generated by ObjectBox Generator in your project. Please follow the [installation instructions](https://github.com/objectbox/objectbox-c#usage-and-installation).

2. Install the objectbox-generator: download the latest binary for your OS: [Releases](https://github.com/objectbox/objectbox-generator/releases/latest) and add it to $PATH for a convenient use.

3. Get FlatBuffers library, depending on whether you use C or C++
    * For C: get [flatc library and headers](https://github.com/dvidelabs/flatcc)
    * For C++: get [flatbuffers headers](https://github.com/google/flatbuffers/tree/v1.12.0/include/flatbuffers); the library is included within objectbox-c library (.so/.dll) so you don't need to link to it separately.

## Getting started

ObjectBox Generator uses FlatBuffer schema file (.fbs) as a source. It stores the model information within a model JSON file known from other ObjectBox language bindings (objectbox-model.json) and generates code based on the selected language - C or C++.

Let’s have a look at a sample schema (`tasklist.fbs`) and how Generator helps us.

```text
table Task {
    id: ulong;
    text: string;
    date_created: ulong;
    date_finished: ulong;
}
```

### For C++ projects

Running `objectbox-generator -cpp tasklist.fbs` will generate C++ binding code for `tasklist.fbs` - we get the following files:

* objectbox-model.h
* objectbox-model.json
* tasklist-cpp.obx.h

> Note: you should add all these files to your source control (e.g. git), most importantly the objectbox-model.json which ensures compatibility with previous versions of your database after you make changes to the schema.

Now in your application, you can include the headers and start to work with your database. Consider the following `main.cpp`:

```cpp
#include "objectbox-cpp.h"
#include "objectbox-model.h"
#include "tasklist-cpp.obx.h"

int main(int argc, char* args[]) {
    // create_obx_model() provided by objectbox-model.h
    // obx interface contents provided by objectbox-ext.h
    obx::Store store(create_obx_model());
    obx::Box<Task> box(store);

    obx_id id = box.put({.text = "Buy milk"});  // Create
    std::unique_ptr<Task> task = box.get(id);   // Read
    if (task) {
        task->text += " & some bread";
        box.put(*task);                         // Update
        box.remove(id);                         // Delete
    }
    return 0;
}
```

To compile, just link to the objectbox-c library, e.g. something like this should work: `g++ main.cpp -I. -std=c++11 -lobjectbox`. Note: the command snippet assumes you have objectbox-c library installed in a path recognized by your OS (e.g. /usr/local/lib/) and all the referenced headers are in the same folder as `main.cpp`.

### For C projects

Running `objectbox-generator -c tasklist.fbs` will generate C binding code for `tasklist.fbs` - we get the following files:

* objectbox-model.h
* objectbox-model.json
* tasklist.obx.h

> Note: you should add all these files to your source control (e.g. git), most importantly the objectbox-model.json which ensures compatibility with previous versions of your database after you make changes to the schema.

Now in your application, you can include the headers and start to work with your database. Have a look at the following `main.c` showing one of the many ways you can work with objectbox-c and the generated code:

```c
#include "objectbox-model.h"
#include "objectbox.h"
#include "tasklist.obx.h"

obx_err print_last_error() {
    printf("Unexpected error: %d %s\n", obx_last_error_code(), obx_last_error_message());
    return obx_last_error_code();
}

obx_id task_put(OBX_box* box, Task* task) {
    flatcc_builder_t builder;
    flatcc_builder_init(&builder);

    size_t size;
    void* buffer;

    // Note: Task_to_flatbuffer() is provided by the generated code
    obx_id id = 0;
    if (Task_to_flatbuffer(&builder, task, &buffer, &size)) {
        id = obx_box_put_object(box, buffer, size,
                                OBXPutMode_PUT);  // returns 0 on error
    }

    flatcc_builder_clear(&builder);

    if (id == 0) {
        // TODO: won't be able to print the right error if it occured in
        // Task_to_flatbuffer(), i.e. outside objectbox
        print_last_error();
    } else {
        task->id = id;  // Note: we're updating the ID on new objects for convenience
    }

    return id;
}

Task* task_read(OBX_store* store, OBX_box* box, obx_id id) {
    OBX_txn* txn = NULL;

    // We need an explicit TX to read - read flatbuffers lifecycle is bound to the
    // open transaction. The transaction can be closed safely after reading the
    // object properties from flatbuffers.
    txn = obx_txn_read(store);
    if (!txn) {
        print_last_error();
        return NULL;
    }

    void* data;
    size_t size;
    int rc = obx_box_get(box, id, &data, &size);
    if (rc != OBX_SUCCESS) {
        // if (rc == OBX_NOT_FOUND); // No special treatment at the moment if not
        // found
        obx_txn_close(txn);
        return NULL;
    }

    Task* result = Task_new_from_flatbuffer(data, size);
    obx_txn_close(txn);
    return result;
}

int main(int argc, char* args[]) {
    int rc = 0;
    OBX_store* store = NULL;
    OBX_box* box = NULL;
    Task* task = NULL;

    // Firstly, we need to create a model for our data and the store
    {
        OBX_model* model = create_obx_model();  // create_obx_model() provided by objectbox-model.h
        if (!model) goto handle_error;
        if (obx_model_error_code(model)) {
            printf("Model error: %d %s\n", obx_model_error_code(model), obx_model_error_message(model));
            obx_model_free(model);
            goto handle_error;
        }

        OBX_store_options* opt = obx_opt();
        obx_opt_model(opt, model);
        store = obx_store_open(opt);
        if (!store) goto handle_error;

        // obx_store_open() takes ownership of model and opt and frees them. We must
        // not access them anymore.
    }

    box = obx_box(store, Task_ENTITY_ID);  // Note the generated "Task_ENTITY_ID"

    obx_id id = 0;

    {  // Create
        Task task = {.text = "Buy milk"};
        id = task_put(box, &task);
        if (!id) goto handle_error;
        printf("New task inserted with ID %d\n", id);
    }

    {  // Read
        task = task_read(store, box, id);
        if (!task) goto handle_error;
        printf("Task %d read with text: %s\n", id, task->text);
    }

    {  // Update
        const char* appendix = " & some bread";

        // updating a string property is a little more involved but nothing we can't
        // manage with a little elbow grease
        size_t old_text_len = task->text ? strlen(task->text) : 0;
        char* new_text = (char*) malloc((old_text_len + strlen(appendix) + 1) * sizeof(char));

        if (task->text) {
            memcpy(new_text, task->text, old_text_len);

            // free the previously allocated memory, which would otherwise be lost
            // when overwritten below
            free(task->text);
        }
        memcpy(new_text + old_text_len, appendix, strlen(appendix) + 1);
        task->text = new_text;
        printf("Updated task %d with a new text: %s\n", id, task->text);
    }

    // Delete
    if (obx_box_remove(box, id) != OBX_SUCCESS) goto handle_error;

free_resources:
    // free any remaining allocated resources
    if (task) Task_free(&task);
    if (store) obx_store_close(store);
    return rc;

// print error and clean up
handle_error:
    rc = print_last_error();
    if (rc <= 0) rc = 1;
    goto free_resources;
}
```

To compile, link to the objectbox-c library and flatcc-runtime library, e.g. something like this should work: `gcc main.c -I. -lobjectbox -lflatccrt`. Note: the command snippet assumes you have objectbox-c and flatccrt libraries installed in a path recognized by your OS (e.g. /usr/local/lib/) and all the referenced headers are in the same folder as `main.c`.
