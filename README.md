<img width="466" src="https://raw.githubusercontent.com/objectbox/objectbox-java/master/logo.png">
<br/>

[![Follow ObjectBox on Twitter](https://img.shields.io/twitter/follow/ObjectBox_io.svg?style=flat-square&logo=twitter&color=fff)](https://twitter.com/ObjectBox_io)

# ObjectBox Generator

Current version: 0.9.1

ObjectBox is a superfast cross-platform object-oriented database.
ObjectBox Generator produces binding code for ObjectBox C and C++ APIs (more languages to be supported in the future).
This greatly simplifies the model declaration and FlatBuffers serialization, allowing you to concentrate on the actual application logic.

All the generated code is header-only and compatible with the existing ObjectBox C and C++ APIs.

## Prerequisites/Installation

1. The source code generated by ObjectBox Generator depends on the [ObjectBox runtime library](https://github.com/objectbox/objectbox-c).
   Please follow the [installation instructions](https://github.com/objectbox/objectbox-c#usage-and-installation).

2. Install the objectbox-generator by downloading the latest binary for your OS from [releases](https://github.com/objectbox/objectbox-generator/releases/latest).
   If you want, add it to $PATH for convenience.
   Alternatively, instead of downloading, you can build the generator yourself by cloning this repo and running `make`.
   To build yourself, you need a recent Go version, CMake and a C++11 tool chain.

3. Get a FlatBuffers library:
    * For C: get [flatcc library and headers](https://github.com/dvidelabs/flatcc)
    * For C++: get [flatbuffers headers](https://github.com/google/flatbuffers/tree/v1.12.0/include/flatbuffers).
      Note: objectbox-c library (.so/.dll) already includes this library.

## Getting started

ObjectBox Generator uses FlatBuffer schema file (.fbs) as its primary input.
The Generator also maintains some metadata around the data model in a JSON file (objectbox-model.json).
Based on these two files, it generates code for the selected language (C or C++).

Let‚Äôs have a look at a sample schema (`tasklist.fbs`) and how Generator helps us.

```text
table Task {
    id: ulong;
    text: string;
    date_created: ulong;
    date_finished: ulong;
}
```

### For C++ projects

To generate C++ binding code, run the Generator with the `-cpp` option and pass the FlatBuffers schema file:

 `objectbox-generator -cpp tasklist.fbs`
 
The following files will be generated:

* objectbox-model.h
* objectbox-model.json
* tasklist-cpp.obx.h

> Note: you should add all these files to your source control (e.g. git), 
> most importantly the objectbox-model.json which ensures compatibility 
> with previous versions of your database after you make changes to the schema.

Now, you can include the generated headers in your application and start working with your database.  
Consider the following `main.cpp`:

```cpp
#include "objectbox-cpp.h"
#include "objectbox-model.h"
#include "tasklist-cpp.obx.h"

int main(int argc, char* args[]) {
    // create_obx_model() provided by objectbox-model.h
    // obx interface contents provided by objectbox-cpp.h
    obx::Store store(create_obx_model());
    obx::Box<Task> box(store);

    obx_id id = box.put({.text = "Buy milk"});  // Create
    std::unique_ptr<Task> task = box.get(id);   // Read
    if (task) {
        task->text += " & some bread";
        box.put(*task);                         // Update
        box.remove(id);                         // Delete
    }
    return 0;
}
```

To compile, just link to the objectbox-c library, e.g. something like this should 
work: `g++ main.cpp -I. -std=c++11 -lobjectbox`. Note: the command snippet assumes 
you have objectbox-c library installed in a path recognized by your OS (e.g. /usr/local/lib/)
and all the referenced headers are in the same folder as `main.cpp`.

### For C projects

Like for C++, you start with calling the Generator, but with the `-c` option to produce plain C code.
For all details check [this C example](c-api-example.md).  

## Annotations

The source FlatBuffer schema can contain some ObjectBox-specific annotations, declared as specially 
formatted comments to `table` and `field` FlatBuffer schema elements. Have a look at the following 
FlatBuffers schema example showing some ObjectBox annotations:

```text
/// This entity is not annotated and only serves as a relation target in this example
table Simple {
    id:ulong;
}

/// objectbox: name=AnnotatedEntity
table Annotated {
    /// Objectbox requires an ID property.
    /// Recognized automatically if it has a right name ("id"), otherwise it must be annotated.
    /// objectbox:id
    identifier:ulong;

    /// objectbox:name="name",index=hash64
    fullName:string;

    /// objectbox:id-companion, date
    time:int64;

    /// objectbox:transient
    skippedField:[uint64];

    /// objectbox:link=Simple
    relId:ulong;
}
```

### Annotation format

To ensure that the annotations are recognized, follow these guidelines:

* Must be a comment immediately preceding an Entity or a Property (no empty lines between them).
* The comment must start with three slashes so it's picked up by FlatBuffer schema parser as a "documentation".
* Spaces between words inside the comment are skipped so you can use them for better readability if you like. See e.g. `Annotated`, `time`.
* The comment must start with the text `objectbox:` and is followed by one or more annotations, separated by commas.
* Each annotation has a name and some annotations also support specifying a value (some even require a value, e.g. the `name` annotation). See e.g. `Annotated`, `relId`.
* Value, if present, is added to the annotation by adding an equal sign and the actual value.
* A value may additionally be surrounded by double quotes but it's not necessary. See e.g. `fullName` showing both variants.

### Supported annotations

The following annotations are currently supported:

#### Entity annotations

* **name** - specifies the name to use in the database if it's desired to be different than what the FlatBuffer schema "table" is called.
* **transient** - this entity is skipped, no code is generated for it. Useful if you have custom FlatBuffer handling but still want to generate ObjectBox binding code for some parts of the same file.
* **uid** - used to explicitly specify UID used with this entity; used when renaming entities. See [Go documentation on schema changes](https://golang.objectbox.io/schema-changes) which apply here as well.

#### Property annotations

* **date** - tells ObjectBox the property is a timestamp, ObjectBox expects the value to be a timestamp since UNIX epoch, in milliseconds.
* **id** - specifies this property is a unique identifier of the object - used for all CRUD operations.
* **id-companion** - identifies a companion property, currently only supported on `date` properties in time-series databases.
* **index** - creates a database index. This can improve performance when querying for that property. You can specify an index type as the annotation value:
  * not specified - automatically choose the index type based on the property type (`hash` for string, `value` for others).
  * `value` - uses property values to build the index. For string, this may require more storage than a hash-based index.
  * `hash` - uses a 32-bit hash of property value to build the index. Occasional collisions may occur which should not have any performance impact in practice (with normal value distribution). Usually, a better choice than `hash64`, as it requires less storage.
  * `hash64` - uses a long hash of property values to build the index. Requires more storage than `hash` and thus should not be the first choice in most cases.
* **link** - declares the field as a relation ID, linking to another Entity which must be specified as a value of this annotation.
* **name** - specifies the name to use in the database if it's desired to be different than what the FlatBuffer schema "field" is called.
* **transient** - this property is skipped, no code is generated for it. Useful if you have custom FlatBuffer handling but still want to generate ObjectBox binding code for the entity.
* **uid** - used to explicitly specify UID used with this property; used when renaming properties. See [Go documentation on schema changes](https://golang.objectbox.io/schema-changes) which apply here as well.
* **unique** - set to enforce that values are unique before an entity is inserted/updated. A `put` operation will abort and return an error if the unique constraint is violated.

# License

```
Copyright (C) 2020 ObjectBox Ltd. All rights reserved.
https://objectbox.io
This file is part of ObjectBox Generator.

ObjectBox Generator is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
ObjectBox Generator is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with ObjectBox Generator.  If not, see <http://www.gnu.org/licenses/>.
```

Note: GPL only applies to the Generator itself and not to generated code.
You can regard generated code as "your code", and we impose no limitation on distributing it.
And, just to clarify: as the Generator does not include any warranty, there can be no warranty for the code it generates.       

# Do you ‚ô•Ô∏è using ObjectBox?

We want to [hear about your project](https://docs.google.com/forms/d/e/1FAIpQLScIYiOIThcq-AnDVoCvnZOMgxO4S-fBtDSFPQfWldJnhi2c7Q/viewform)!
It will - literally - take just a minute, but help us a lot. Thank you!‚Äã üôè‚Äã
