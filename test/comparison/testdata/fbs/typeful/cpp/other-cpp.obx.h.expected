// Code generated by ObjectBox; DO NOT EDIT.

#pragma once

#include <stdbool.h>
#include <stdint.h>

#include "flatbuffers/flatbuffers.h"
#include "objectbox.h"

namespace test {
struct Other_;

struct Other {
    using _OBX_MetaInfo = Other_;
    
    uint64_t id;
    int32_t value;
};

struct Other_ {
    static const obx_schema_id id = 1;
    static const obx_schema_id value = 2;

    static constexpr obx_schema_id entityId() { return 1; }

    static void setObjectId(Other& object, obx_id newId) { object.id = newId; }

    /// Write given object to the FlatBufferBuilder
    static void toFlatBuffer(flatbuffers::FlatBufferBuilder& fbb, const Other& object);

    /// Read an object from a valid FlatBuffer
    static Other fromFlatBuffer(const void* data, size_t size);

    /// Read an object from a valid FlatBuffer
    static std::unique_ptr<Other> newFromFlatBuffer(const void* data, size_t size);

    /// Read an object from a valid FlatBuffer
    static void fromFlatBuffer(const void* data, size_t size, Other& outObject);
};
}  // namespace test

namespace test2 {
namespace multi {
struct Another_;

struct Another {
    using _OBX_MetaInfo = Another_;
    
    uint64_t id;
    int32_t value;
};

struct Another_ {
    static const obx_schema_id id = 1;
    static const obx_schema_id value = 2;

    static constexpr obx_schema_id entityId() { return 2; }

    static void setObjectId(Another& object, obx_id newId) { object.id = newId; }

    /// Write given object to the FlatBufferBuilder
    static void toFlatBuffer(flatbuffers::FlatBufferBuilder& fbb, const Another& object);

    /// Read an object from a valid FlatBuffer
    static Another fromFlatBuffer(const void* data, size_t size);

    /// Read an object from a valid FlatBuffer
    static std::unique_ptr<Another> newFromFlatBuffer(const void* data, size_t size);

    /// Read an object from a valid FlatBuffer
    static void fromFlatBuffer(const void* data, size_t size, Another& outObject);
};
}  // namespace multi
}  // namespace test2

inline void test::Other_::toFlatBuffer(flatbuffers::FlatBufferBuilder& fbb, const test::Other& object) {
    fbb.Clear();
    flatbuffers::uoffset_t fbStart = fbb.StartTable();
    fbb.TrackField(4, fbb.PushElement<uint64_t>(object.id));
    fbb.TrackField(6, fbb.PushElement<int32_t>(object.value));
    flatbuffers::Offset<flatbuffers::Table> offset;
    offset.o = fbb.EndTable(fbStart);
    fbb.Finish(offset);
}

inline test::Other test::Other_::fromFlatBuffer(const void* data, size_t size) {
    test::Other object;
    fromFlatBuffer(data, size, object);
    return object;
}

inline std::unique_ptr<test::Other> test::Other_::newFromFlatBuffer(const void* data, size_t size) {
    auto object = std::unique_ptr<test::Other>(new test::Other());
    fromFlatBuffer(data, size, *object);
    return object;
}

inline void test::Other_::fromFlatBuffer(const void* data, size_t size, test::Other& outObject) {
    const auto* table = flatbuffers::GetRoot<flatbuffers::Table>(data);
    assert(table);
    outObject.id = table->GetField<uint64_t>(4, 0);
    outObject.value = table->GetField<int32_t>(6, 0);
    
}

inline void test2::multi::Another_::toFlatBuffer(flatbuffers::FlatBufferBuilder& fbb, const test2::multi::Another& object) {
    fbb.Clear();
    flatbuffers::uoffset_t fbStart = fbb.StartTable();
    fbb.TrackField(4, fbb.PushElement<uint64_t>(object.id));
    fbb.TrackField(6, fbb.PushElement<int32_t>(object.value));
    flatbuffers::Offset<flatbuffers::Table> offset;
    offset.o = fbb.EndTable(fbStart);
    fbb.Finish(offset);
}

inline test2::multi::Another test2::multi::Another_::fromFlatBuffer(const void* data, size_t size) {
    test2::multi::Another object;
    fromFlatBuffer(data, size, object);
    return object;
}

inline std::unique_ptr<test2::multi::Another> test2::multi::Another_::newFromFlatBuffer(const void* data, size_t size) {
    auto object = std::unique_ptr<test2::multi::Another>(new test2::multi::Another());
    fromFlatBuffer(data, size, *object);
    return object;
}

inline void test2::multi::Another_::fromFlatBuffer(const void* data, size_t size, test2::multi::Another& outObject) {
    const auto* table = flatbuffers::GetRoot<flatbuffers::Table>(data);
    assert(table);
    outObject.id = table->GetField<uint64_t>(4, 0);
    outObject.value = table->GetField<int32_t>(6, 0);
    
}

