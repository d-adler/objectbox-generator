// Code generated by ObjectBox; DO NOT EDIT.

#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "flatcc/flatcc.h"
#include "flatcc/flatcc_builder.h"
#include "objectbox.h"

/// Internal function used in other generated functions to put (write) explicitly typed objects 
static obx_id synced_obx_h_put_object(OBX_box* box, void* object,
                             bool (*to_flatbuffer)(flatcc_builder_t*, const void*, void**, size_t*), OBXPutMode mode);

/// Internal function used in other generated functions to get (read) explicitly typed objects
static void* synced_obx_h_get_object(OBX_box* box, obx_id id, void* (*from_flatbuffer)(const void*, size_t));


typedef struct SyncedEntity {
    uint64_t id;
    uint64_t propRelId;
    
} SyncedEntity;

enum SyncedEntity_ {
    SyncedEntity_ENTITY_ID = 5,
    SyncedEntity_PROP_ID_id = 1,
    SyncedEntity_PROP_ID_propRelId = 2,
    SyncedEntity_REL_ID_standaloneRel = 3,
};

/// Write given object to the FlatBufferBuilder
static bool SyncedEntity_to_flatbuffer(flatcc_builder_t* B, const SyncedEntity* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling SyncedEntity_free_pointers().
/// Thus, when calling this function multiple times on the same object, ensure to call SyncedEntity_free_pointers() before subsequent calls to avoid leaks. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool SyncedEntity_from_flatbuffer(const void* data, size_t size, SyncedEntity* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling SyncedEntity_free();
static SyncedEntity* SyncedEntity_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties, setting the freed pointers to NULL.  
static void SyncedEntity_free_pointers(SyncedEntity* object);

/// Free SyncedEntity* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling SyncedEntity_free_pointers() followed by free();
static void SyncedEntity_free(SyncedEntity* object);

typedef struct SyncedRelTarget {
    uint64_t id;
    
} SyncedRelTarget;

enum SyncedRelTarget_ {
    SyncedRelTarget_ENTITY_ID = 6,
    SyncedRelTarget_PROP_ID_id = 1,
};

/// Write given object to the FlatBufferBuilder
static bool SyncedRelTarget_to_flatbuffer(flatcc_builder_t* B, const SyncedRelTarget* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling SyncedRelTarget_free_pointers().
/// Thus, when calling this function multiple times on the same object, ensure to call SyncedRelTarget_free_pointers() before subsequent calls to avoid leaks. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool SyncedRelTarget_from_flatbuffer(const void* data, size_t size, SyncedRelTarget* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling SyncedRelTarget_free();
static SyncedRelTarget* SyncedRelTarget_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties, setting the freed pointers to NULL.  
static void SyncedRelTarget_free_pointers(SyncedRelTarget* object);

/// Free SyncedRelTarget* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling SyncedRelTarget_free_pointers() followed by free();
static void SyncedRelTarget_free(SyncedRelTarget* object);

static bool SyncedEntity_to_flatbuffer(flatcc_builder_t* B, const SyncedEntity* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    

    if (flatcc_builder_start_table(B, 2) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
    flatbuffers_uint64_write_to_pe(p, object->id);
    
    if (!(p = flatcc_builder_table_add(B, 1, 8, 8))) return false;
    flatbuffers_uint64_write_to_pe(p, object->propRelId);
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool SyncedEntity_from_flatbuffer(const void* data, size_t size, SyncedEntity* out_object) {
    assert(data);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    flatbuffers_voffset_t *vt = (flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    out_object->id = (vs < sizeof(vt[0]) * (0 + 3)) ? 0 : flatbuffers_uint64_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 0 + 2));
    out_object->propRelId = (vs < sizeof(vt[0]) * (1 + 3)) ? 0 : flatbuffers_uint64_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 1 + 2));
    return true;
}

static SyncedEntity* SyncedEntity_new_from_flatbuffer(const void* data, size_t size) {
    SyncedEntity* object = (SyncedEntity*) malloc(sizeof(SyncedEntity));
    if (object) {
        if (!SyncedEntity_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void SyncedEntity_free_pointers(SyncedEntity* object) {
    if (object == NULL) return;
}

static void SyncedEntity_free(SyncedEntity* object) {
    SyncedEntity_free_pointers(object);
    free(object);
}

/// Insert or update the given object in the database.
/// @param object (in & out) will be updated with a newly inserted ID if the one specified previously was zero. If an ID 
/// was already specified (non-zero), it will remain unchanged.
/// @return object ID from the object param (see object param docs) or a zero on error. If a zero was returned, you can
/// check obx_last_error_*() to get the error details. In an unlikely event that those functions return no error
/// code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
static obx_id SyncedEntity_put(OBX_box* box, SyncedEntity* object) {
    obx_id id = synced_obx_h_put_object(box, object,
                               (bool (*)(flatcc_builder_t*, const void*, void**, size_t*)) SyncedEntity_to_flatbuffer,
                               OBXPutMode_PUT);
    if (id != 0) {
        object->id = id;  // update the ID property on new objects for convenience
    }
    return id;
}

/// Read an object from the database, returning a pointer.
/// @return an object pointer or NULL if an object with the given ID doesn't exist or any other error occurred. You can
/// check obx_last_error_*() if NULL is returned to get the error details. In an unlikely event that those functions
/// return no error code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
/// @note: The returned object must be freed after use by calling SyncedEntity_free();
static SyncedEntity* SyncedEntity_get(OBX_box* box, obx_id id) {
    return (SyncedEntity*) synced_obx_h_get_object(box, id, (void* (*) (const void*, size_t)) SyncedEntity_new_from_flatbuffer);
}

static bool SyncedRelTarget_to_flatbuffer(flatcc_builder_t* B, const SyncedRelTarget* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    

    if (flatcc_builder_start_table(B, 1) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
    flatbuffers_uint64_write_to_pe(p, object->id);
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool SyncedRelTarget_from_flatbuffer(const void* data, size_t size, SyncedRelTarget* out_object) {
    assert(data);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    flatbuffers_voffset_t *vt = (flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    out_object->id = (vs < sizeof(vt[0]) * (0 + 3)) ? 0 : flatbuffers_uint64_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 0 + 2));
    return true;
}

static SyncedRelTarget* SyncedRelTarget_new_from_flatbuffer(const void* data, size_t size) {
    SyncedRelTarget* object = (SyncedRelTarget*) malloc(sizeof(SyncedRelTarget));
    if (object) {
        if (!SyncedRelTarget_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void SyncedRelTarget_free_pointers(SyncedRelTarget* object) {
    if (object == NULL) return;
}

static void SyncedRelTarget_free(SyncedRelTarget* object) {
    SyncedRelTarget_free_pointers(object);
    free(object);
}

/// Insert or update the given object in the database.
/// @param object (in & out) will be updated with a newly inserted ID if the one specified previously was zero. If an ID 
/// was already specified (non-zero), it will remain unchanged.
/// @return object ID from the object param (see object param docs) or a zero on error. If a zero was returned, you can
/// check obx_last_error_*() to get the error details. In an unlikely event that those functions return no error
/// code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
static obx_id SyncedRelTarget_put(OBX_box* box, SyncedRelTarget* object) {
    obx_id id = synced_obx_h_put_object(box, object,
                               (bool (*)(flatcc_builder_t*, const void*, void**, size_t*)) SyncedRelTarget_to_flatbuffer,
                               OBXPutMode_PUT);
    if (id != 0) {
        object->id = id;  // update the ID property on new objects for convenience
    }
    return id;
}

/// Read an object from the database, returning a pointer.
/// @return an object pointer or NULL if an object with the given ID doesn't exist or any other error occurred. You can
/// check obx_last_error_*() if NULL is returned to get the error details. In an unlikely event that those functions
/// return no error code/message, the error occurred in FlatBuffers serialization, e.g. due to memory allocation issues.
/// @note: The returned object must be freed after use by calling SyncedRelTarget_free();
static SyncedRelTarget* SyncedRelTarget_get(OBX_box* box, obx_id id) {
    return (SyncedRelTarget*) synced_obx_h_get_object(box, id, (void* (*) (const void*, size_t)) SyncedRelTarget_new_from_flatbuffer);
}

static obx_id synced_obx_h_put_object(OBX_box* box, void* object,
                             bool (*to_flatbuffer)(flatcc_builder_t*, const void*, void**, size_t*), OBXPutMode mode) {
    flatcc_builder_t builder;
    flatcc_builder_init(&builder);

    obx_id id = 0;
    size_t size = 0;
    void* buffer = NULL;
    if (!to_flatbuffer(&builder, object, &buffer, &size)) {
        obx_last_error_set(OBX_ERROR_STD_OTHER, 0, "FlatBuffer serialization failed");
    } else {
        id = obx_box_put_object4(box, buffer, size, mode);  // 0 on error
    }

    flatcc_builder_clear(&builder);
    if (buffer) flatcc_builder_aligned_free(buffer);

    return id;
}

static void* synced_obx_h_get_object(OBX_box* box, obx_id id, void* (*from_flatbuffer)(const void*, size_t)) {
    // We need an explicit TX - read data lifecycle is bound to the open TX.
    OBX_txn* tx = obx_txn_read(obx_box_store(box));
    if (!tx) return NULL;

    void* result = NULL;
    void* data;
    size_t size;
    if (obx_box_get(box, id, &data, &size) == OBX_SUCCESS) {
        result = from_flatbuffer(data, size);
        if (result == NULL) {
            obx_last_error_set(OBX_ERROR_STD_OTHER, 0, "FlatBuffer deserialization failed");
        }
    }

    obx_txn_close(tx);
    return result;
}
