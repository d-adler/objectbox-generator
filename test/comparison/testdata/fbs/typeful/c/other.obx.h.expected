// Code generated by ObjectBox; DO NOT EDIT.

#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#include "flatcc/flatcc.h"
#include "flatcc/flatcc_builder.h"
#include "objectbox.h"

typedef struct test_Other {
    uint64_t id;
    int32_t value;
    
} test_Other;

enum test_Other_ {
    test_Other_ENTITY_ID = 1,
    test_Other_PROP_ID_id = 1,
    test_Other_PROP_ID_value = 2,
};

/// Write given object to the FlatBufferBuilder
static bool test_Other_to_flatbuffer(flatcc_builder_t* B, const test_Other* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling test_Other_free_pointers().
/// If the given object already contains un-freed pointers, the memory will be lost - free manually before calling this function on the same object twice. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool test_Other_from_flatbuffer(const void* data, size_t size, test_Other* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling test_Other_free();
static test_Other* test_Other_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties.  
static void test_Other_free_pointers(test_Other* object);

/// Free test_Other* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling test_Other_free_pointers() followed by free();
static void test_Other_free(test_Other* object);

typedef struct test2_multi_Another {
    uint64_t id;
    int32_t value;
    
} test2_multi_Another;

enum test2_multi_Another_ {
    test2_multi_Another_ENTITY_ID = 2,
    test2_multi_Another_PROP_ID_id = 1,
    test2_multi_Another_PROP_ID_value = 2,
};

/// Write given object to the FlatBufferBuilder
static bool test2_multi_Another_to_flatbuffer(flatcc_builder_t* B, const test2_multi_Another* object, void** out_buffer, size_t* out_size);

/// Read an object from a valid FlatBuffer.
/// If the read object contains vectors or strings, those are allocated on heap and must be freed after use by calling test2_multi_Another_free_pointers().
/// If the given object already contains un-freed pointers, the memory will be lost - free manually before calling this function on the same object twice. 
/// @returns true if the object was deserialized successfully or false on (allocation) error in which case any memory 
///          allocated by this function will also be freed before returning, allowing you to retry.
static bool test2_multi_Another_from_flatbuffer(const void* data, size_t size, test2_multi_Another* out_object);

/// Read an object from a valid FlatBuffer, allocating the object on heap. 
/// The object must be freed after use by calling test2_multi_Another_free();
static test2_multi_Another* test2_multi_Another_new_from_flatbuffer(const void* data, size_t size);

/// Free memory allocated for vector and string properties.  
static void test2_multi_Another_free_pointers(test2_multi_Another* object);

/// Free test2_multi_Another* object pointer and all its property pointers (vectors and strings).
/// Equivalent to calling test2_multi_Another_free_pointers() followed by free();
static void test2_multi_Another_free(test2_multi_Another* object);

static bool test_Other_to_flatbuffer(flatcc_builder_t* B, const test_Other* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    

    if (flatcc_builder_start_table(B, 2) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
    flatbuffers_uint64_write_to_pe(p, object->id);
    
    if (!(p = flatcc_builder_table_add(B, 1, 4, 4))) return false;
    flatbuffers_int32_write_to_pe(p, object->value);
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool test_Other_from_flatbuffer(const void* data, size_t size, test_Other* out_object) {
    assert(data);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    flatbuffers_voffset_t *vt = (flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    out_object->id = (vs < sizeof(vt[0]) * (0 + 3)) ? 0 : flatbuffers_uint64_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 0 + 2));
    out_object->value = (vs < sizeof(vt[0]) * (1 + 3)) ? 0 : flatbuffers_int32_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 1 + 2));
    return true;
}

static test_Other* test_Other_new_from_flatbuffer(const void* data, size_t size) {
    test_Other* object = (test_Other*) malloc(sizeof(test_Other));
    if (object != NULL) {
        if (!test_Other_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void test_Other_free_pointers(test_Other* object) {
    if (!object) return;
}

static void test_Other_free(test_Other* object) {
    test_Other_free_pointers(object);
    free(object);
}

static bool test2_multi_Another_to_flatbuffer(flatcc_builder_t* B, const test2_multi_Another* object, void** out_buffer, size_t* out_size) {
    assert(B);
    assert(object);
    assert(out_buffer);
    assert(out_size);

    flatcc_builder_reset(B);
    flatcc_builder_start_buffer(B, 0, 0, 0);
    

    if (flatcc_builder_start_table(B, 2) != 0) return false;

    void* p;
    flatcc_builder_ref_t* _p;
    
    if (!(p = flatcc_builder_table_add(B, 0, 8, 8))) return false;
    flatbuffers_uint64_write_to_pe(p, object->id);
    
    if (!(p = flatcc_builder_table_add(B, 1, 4, 4))) return false;
    flatbuffers_int32_write_to_pe(p, object->value);
    
    flatcc_builder_ref_t ref;
    if (!(ref = flatcc_builder_end_table(B))) return false;
    if (!flatcc_builder_end_buffer(B, ref)) return false;
    return (*out_buffer = flatcc_builder_finalize_aligned_buffer(B, out_size)) != NULL;
}

static bool test2_multi_Another_from_flatbuffer(const void* data, size_t size, test2_multi_Another* out_object) {
    assert(data);
    assert(out_object);

    const uint8_t* table = (const uint8_t*) data + __flatbuffers_uoffset_read_from_pe(data);
    assert(table);
    flatbuffers_voffset_t *vt = (flatbuffers_voffset_t*) (table - __flatbuffers_soffset_read_from_pe(table));
    flatbuffers_voffset_t vs = __flatbuffers_voffset_read_from_pe(vt);

    // variables reused when reading strings and vectors
    flatbuffers_voffset_t offset;
    const flatbuffers_uoffset_t* val;
    size_t len;

    out_object->id = (vs < sizeof(vt[0]) * (0 + 3)) ? 0 : flatbuffers_uint64_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 0 + 2));
    out_object->value = (vs < sizeof(vt[0]) * (1 + 3)) ? 0 : flatbuffers_int32_read_from_pe(table + __flatbuffers_voffset_read_from_pe(vt + 1 + 2));
    return true;
}

static test2_multi_Another* test2_multi_Another_new_from_flatbuffer(const void* data, size_t size) {
    test2_multi_Another* object = (test2_multi_Another*) malloc(sizeof(test2_multi_Another));
    if (object != NULL) {
        if (!test2_multi_Another_from_flatbuffer(data, size, object)) {
            free(object);
            object = NULL;
        }
    }
    return object;
}

static void test2_multi_Another_free_pointers(test2_multi_Another* object) {
    if (!object) return;
}

static void test2_multi_Another_free(test2_multi_Another* object) {
    test2_multi_Another_free_pointers(object);
    free(object);
}

